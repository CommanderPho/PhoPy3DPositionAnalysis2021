"""
This type stub file was generated by pyright.
"""

import pandas as pd
from typing import Optional, Union
from importlib import metadata
from neuropy.utils.mixins.dataframe_representable import DataFrameInitializable, DataFrameRepresentable
from .datawriter import DataWriter
from neuropy.utils.mixins.print_helpers import OrderedMeta, SimplePrintable
from neuropy.utils.mixins.time_slicing import StartStopTimesMixin, TimeColumnAliasesProtocol, TimeSlicableObjectProtocol, TimeSlicedMixin
from neuropy.utils.mixins.HDF5_representable import HDFMixin

class NamedTimerange(SimplePrintable, metaclass=OrderedMeta):
    """ A simple named period of time with a known start and end time """
    def __init__(self, name, start_end_times) -> None:
        ...
    
    @property
    def t_start(self):
        ...
    
    @t_start.setter
    def t_start(self, t): # -> None:
        ...
    
    @property
    def duration(self):
        ...
    
    @property
    def t_stop(self):
        ...
    
    @t_stop.setter
    def t_stop(self, t): # -> None:
        ...
    
    def to_Epoch(self): # -> Epoch:
        ...
    


@pd.api.extensions.register_dataframe_accessor("epochs")
class EpochsAccessor(TimeColumnAliasesProtocol, TimeSlicedMixin, StartStopTimesMixin, TimeSlicableObjectProtocol):
    """ A Pandas pd.DataFrame representation of [start, stop, label] epoch intervals """
    _time_column_name_synonyms = ...
    _required_column_names = ...
    def __init__(self, pandas_obj) -> None:
        ...
    
    @property
    def is_valid(self): # -> Literal[True]:
        """ The dataframe is valid (because it passed _validate(...) in __init__(...) so just return True."""
        ...
    
    @property
    def starts(self):
        ...
    
    @property
    def midtimes(self):
        """ since each epoch is given by a (start, stop) time, the midtimes are the center of this epoch. """
        ...
    
    @property
    def stops(self):
        ...
    
    @property
    def t_start(self):
        ...
    
    @t_start.setter
    def t_start(self, t): # -> None:
        ...
    
    @property
    def duration(self):
        ...
    
    @property
    def t_stop(self):
        ...
    
    @property
    def durations(self):
        ...
    
    @property
    def n_epochs(self): # -> int:
        ...
    
    @property
    def labels(self):
        ...
    
    @property
    def extra_data_column_names(self): # -> list[Any]:
        """Any additional columns in the dataframe beyond those that exist by default. """
        ...
    
    @property
    def extra_data_dataframe(self) -> pd.DataFrame:
        """The subset of the dataframe containing additional information in its columns beyond that what is required. """
        ...
    
    def as_array(self):
        ...
    
    def get_unique_labels(self):
        ...
    
    def get_start_stop_tuples_list(self): # -> list[tuple[Any, Any]]:
        """ returns a list of (start, stop) tuples. """
        ...
    
    def get_valid_df(self):
        """ gets a validated copy of the dataframe. Looks better than doing `epochs_df.epochs._obj` """
        ...
    
    def get_non_overlapping_df(self, debug_print=...) -> pd.DataFrame:
        """ Returns a dataframe with overlapping epochs removed. """
        ...
    
    def get_epochs_longer_than(self, minimum_duration, debug_print=...):
        """ returns a copy of the dataframe contining only epochs longer than the specified minimum_duration. """
        ...
    
    def time_slice(self, t_start, t_stop):
        ...
    
    def label_slice(self, label):
        ...
    
    def filtered_by_duration(self, min_duration=..., max_duration=...):
        ...
    
    @classmethod
    def from_PortionInterval(cls, portion_interval): # -> DataFrame[Any]:
        ...
    
    def to_PortionInterval(self): # -> Interval:
        ...
    


class Epoch(HDFMixin, StartStopTimesMixin, TimeSlicableObjectProtocol, DataFrameRepresentable, DataFrameInitializable, DataWriter):
    """ An Epoch object holds one ore more periods of time (marked by start/end timestamps) along with their corresponding metadata.

    """
    def __init__(self, epochs: pd.DataFrame, metadata=...) -> None:
        """[summary]
        Args:
            epochs (pd.DataFrame): Each column is a pd.Series(["start", "stop", "label"])
            metadata (dict, optional): [description]. Defaults to None.
        """
        ...
    
    @property
    def starts(self):
        ...
    
    @property
    def stops(self):
        ...
    
    @property
    def t_start(self):
        ...
    
    @t_start.setter
    def t_start(self, t): # -> None:
        ...
    
    @property
    def duration(self):
        ...
    
    @property
    def t_stop(self):
        ...
    
    @property
    def durations(self):
        ...
    
    @property
    def midtimes(self):
        """ since each epoch is given by a (start, stop) time, the midtimes are the center of this epoch. """
        ...
    
    @property
    def n_epochs(self):
        ...
    
    @property
    def labels(self):
        ...
    
    def get_unique_labels(self):
        ...
    
    def get_named_timerange(self, epoch_name): # -> NamedTimerange:
        ...
    
    @property
    def metadata(self): # -> dict[Any, Any]:
        ...
    
    @metadata.setter
    def metadata(self, metadata): # -> None:
        """metadata compatibility"""
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __len__(self): # -> int:
        """ allows using `len(epochs_obj)` and getting the number of epochs. """
        ...
    
    def str_for_concise_display(self) -> str:
        """ returns a minimally descriptive string like: '60 epochs in (17.9, 524.1)' that doesn't print all the array elements only the number of epochs and the first and last. """
        ...
    
    def str_for_filename(self) -> str:
        ...
    
    def __getitem__(self, slice_): # -> NDArray[Any]:
        ...
    
    def time_slice(self, t_start, t_stop): # -> Epoch:
        ...
    
    def label_slice(self, label): # -> Epoch:
        ...
    
    def boolean_indicies_slice(self, boolean_indicies): # -> Epoch:
        ...
    
    def filtered_by_duration(self, min_duration=..., max_duration=...): # -> Epoch:
        ...
    
    @classmethod
    def filter_epochs(cls, curr_epochs: Union[pd.DataFrame, Epoch], pos_df: Optional[pd.DataFrame] = ..., spikes_df: pd.DataFrame = ..., require_intersecting_epoch: Epoch = ..., min_epoch_included_duration=..., max_epoch_included_duration=..., maximum_speed_thresh=..., min_inclusion_fr_active_thresh=..., min_num_unique_aclu_inclusions=..., debug_print=...) -> Epoch:
        """filters the provided replay epochs by specified constraints.

        Args:
            curr_epochs (Epoch): the epochs to filter on
            min_epoch_included_duration (float, optional): all epochs shorter than min_epoch_included_duration will be excluded from analysis. Defaults to 0.06.
            max_epoch_included_duration (float, optional): all epochs longer than max_epoch_included_duration will be excluded from analysis. Defaults to 0.6.
            maximum_speed_thresh (float, optional): epochs are only included if the animal's interpolated speed (as determined from the session's position dataframe) is below the speed. Defaults to 2.0 [cm/sec].
            min_inclusion_fr_active_thresh: minimum firing rate (in Hz) for a unit to be considered "active" for inclusion.
            min_num_unique_aclu_inclusions: minimum number of unique active cells that must be included in an epoch to have it included.

            save_on_compute (bool, optional): _description_. Defaults to False.
            debug_print (bool, optional): _description_. Defaults to False.

        Returns:
            Epoch: the filtered epochs as an Epoch object

        NOTE: this really is a general method that works for any Epoch object or Epoch-type dataframe to filter it.

        TODO 2023-04-11 - This really belongs in the Epoch class or the epoch dataframe accessor. 

        """
        ...
    
    def to_dict(self, recurrsively=...): # -> dict[str, Any]:
        ...
    
    @staticmethod
    def from_dict(d: dict): # -> Epoch:
        ...
    
    def fill_blank(self, method=...): # -> None:
        ...
    
    def delete_in_between(self, t1, t2): # -> Epoch:
        ...
    
    def get_proportion_by_label(self, t_start=..., t_stop=...): # -> dict[Any, Any]:
        ...
    
    def count(self, t_start=..., t_stop=..., binsize=...): # -> NDArray[Any]:
        ...
    
    def to_neuroscope(self, ext=...): # -> Path:
        """ exports to a Neuroscope compatable .evt file. """
        ...
    
    def as_array(self):
        ...
    
    @classmethod
    def from_PortionInterval(cls, portion_interval, metadata=...): # -> Epoch:
        ...
    
    def to_PortionInterval(self):
        ...
    
    def get_non_overlapping(self, debug_print=...): # -> Epoch:
        """ Returns a copy with overlapping epochs removed. """
        ...
    
    def to_hdf(self, file_path, key: str, **kwargs): # -> None:
        """ Saves the object to key in the hdf5 file specified by file_path
        Usage:
            hdf5_output_path: Path = curr_active_pipeline.get_output_path().joinpath('test_data.h5')
            _pos_obj: Position = long_one_step_decoder_1D.pf.position
            _pos_obj.to_hdf(hdf5_output_path, key='pos')
        """
        ...
    
    @classmethod
    def read_hdf(cls, file_path, key: str, **kwargs) -> Epoch:
        """  Reads the data from the key in the hdf5 file at file_path
        Usage:
            _reread_pos_obj = Epoch.read_hdf(hdf5_output_path, key='pos')
            _reread_pos_obj
        """
        ...
    
    def to_dataframe(self):
        ...
    
    @classmethod
    def from_dataframe(cls, df): # -> Self:
        ...
    


