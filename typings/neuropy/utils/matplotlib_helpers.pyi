"""
This type stub file was generated by pyright.
"""

import contextlib
from enum import unique
from matplotlib.widgets import RectangleSelector, SpanSelector
from neuropy.utils.misc import AutoNameEnum
from typing import Optional, TYPE_CHECKING
from attrs import define
from matplotlib.figure import Figure

if TYPE_CHECKING:
    ...
Width_Height_Tuple = ...
def compute_data_extent(xpoints, *other_1d_series): # -> NDArray[float64]:
    """Computes the outer bounds, or "extent" of one or more 1D data series.

    Args:
        xpoints ([type]): [description]
        other_1d_series: any number of other 1d data series

    Returns:
        xmin, xmax, ymin, ymax, imin, imax, ...: a flat list of paired min, max values for each data series provided.
        
    Usage:
        # arbitrary number of data sequences:        
        xmin, xmax, ymin, ymax, x_center_min, x_center_max, y_center_min, y_center_max = compute_data_extent(active_epoch_placefields2D.ratemap.xbin, active_epoch_placefields2D.ratemap.ybin, active_epoch_placefields2D.ratemap.xbin_centers, active_epoch_placefields2D.ratemap.ybin_centers)
        print(xmin, xmax, ymin, ymax, x_center_min, x_center_max, y_center_min, y_center_max)

        # simple 2D extent:
        extent = compute_data_extent(active_epoch_placefields2D.ratemap.xbin, active_epoch_placefields2D.ratemap.ybin)
        print(extent)
    """
    ...

def compute_data_aspect_ratio(xbin, ybin, sorted_inputs=...): # -> tuple[Any, Width_Height_Tuple]:
    """Computes the aspect ratio of the provided data

    Args:
        xbin ([type]): [description]
        ybin ([type]): [description]
        sorted_inputs (bool, optional): whether the input arrays are pre-sorted in ascending order or not. Defaults to True.

    Returns:
        float: The aspect ratio of the data such that multiplying any height by the returned float would result in a width in the same aspect ratio as the data.
    """
    ...

@unique
class enumTuningMap2DPlotMode(AutoNameEnum):
    PCOLORFAST = ...
    PCOLORMESH = ...
    PCOLOR = ...
    IMSHOW = ...


@unique
class enumTuningMap2DPlotVariables(AutoNameEnum):
    TUNING_MAPS = ...
    SPIKES_MAPS = ...
    OCCUPANCY = ...


def add_inner_title(ax, title, loc, strokewidth=..., stroke_foreground=..., text_foreground=..., **kwargs): # -> AnchoredText:
    """used to add a figure title inside the border of the figure (instead of outside)
    """
    ...

def draw_sizebar(ax): # -> None:
    """
    Draw a horizontal bar with length of 0.1 in data coordinates,
    with a fixed label underneath.
    """
    ...

def build_or_reuse_figure(fignum=..., fig=..., fig_idx: int = ..., **kwargs): # -> Figure:
    """ Reuses a Matplotlib figure if it exists, or creates a new one if needed
    Inputs:
        fignum - an int or str that identifies a figure
        fig - an existing Matplotlib figure
        fig_idx:int - an index to identify this figure as part of a series of related figures, e.g. plot_pf_1D[0], plot_pf_1D[1], ... 
        **kwargs - are passed as kwargs to the plt.figure(...) command when creating a new figure
    Outputs:
        fig: a Matplotlib figure object

    History: factored out of `plot_ratemap_2D`
    """
    ...

def scale_title_label(ax, curr_title_obj, curr_im, debug_print=...): # -> None:
    """ Scales some matplotlib-based figures titles to be reasonable. I remember that this was important and hard to make, but don't actually remember what it does as of 2022-10-24. It needs to be moved in to somewhere else.
    

    History: From PendingNotebookCode's 2022-11-09 section


    Usage:

        from neuropy.utils.matplotlib_helpers import scale_title_label

        ## Scale all:
        _display_outputs = widget.last_added_display_output
        curr_graphics_objs = _display_outputs.graphics[0]

        ''' curr_graphics_objs is:
        {2: {'axs': [<Axes:label='2'>],
        'image': <matplotlib.image.AxesImage at 0x1630c4556d0>,
        'title_obj': <matplotlib.offsetbox.AnchoredText at 0x1630c4559a0>},
        4: {'axs': [<Axes:label='4'>],
        'image': <matplotlib.image.AxesImage at 0x1630c455f70>,
        'title_obj': <matplotlib.offsetbox.AnchoredText at 0x1630c463280>},
        5: {'axs': [<Axes:label='5'>],
        'image': <matplotlib.image.AxesImage at 0x1630c463850>,
        'title_obj': <matplotlib.offsetbox.AnchoredText at 0x1630c463b20>},
        ...
        '''
        for aclu, curr_neuron_graphics_dict in curr_graphics_objs.items():
            curr_title_obj = curr_neuron_graphics_dict['title_obj'] # matplotlib.offsetbox.AnchoredText
            curr_title_text_obj = curr_title_obj.txt.get_children()[0] # Text object
            curr_im = curr_neuron_graphics_dict['image'] # matplotlib.image.AxesImage
            curr_ax = curr_neuron_graphics_dict['axs'][0]
            scale_title_label(curr_ax, curr_title_obj, curr_im)

    
    """
    ...

def add_value_labels(ax, spacing=..., labels=...): # -> None:
    """Add labels to the end (top) of each bar in a bar chart.

    Arguments:
        ax (matplotlib.axes.Axes): The matplotlib object containing the axes of the plot to annotate.
        spacing (int): The distance between the labels and the bars.

    History:
        Factored out of `plot_short_v_long_pf1D_scalar_overlap_comparison` on 2023-03-28

    Usage:
        from neuropy.utils.matplotlib_helpers import add_value_labels
        # Call the function above. All the magic happens there.
        add_value_labels(ax, labels=x_labels) # 

    """
    ...

def fit_both_axes(ax_lhs, ax_rhs): # -> tuple[tuple[Any, Any], tuple[Any, Any]]:
    """ 2023-05-25 - Computes the x and y bounds needed to fit all data on both axes, and the actually applies these bounds to each. """
    ...

@define(slots=False)
class FigureMargins:
    top_margin: float = ...
    left_margin: float = ...
    right_margin: float = ...
    bottom_margin: float = ...


@define(slots=False)
class FormattedFigureText:
    """ builds flexitext matplotlib figure title and footers 

    Consistent color scheme:
        Long: Red
        Short: Blue

        Context footer is along the bottom of the figure in gray.


    Usage:
        
        from neuropy.utils.matplotlib_helpers import FormattedFigureText

        # `flexitext` version:
        text_formatter = FormattedFigureText()
        plt.title('')
        plt.suptitle('')
        text_formatter.setup_margins(fig)

        ## Need to extract the track name ('maze1') for the title in this plot. 
        track_name = active_context.get_description(subset_includelist=['filter_name'], separator=' | ') # 'maze1'
        # TODO: do we want to convert this into "long" or "short"?
        header_text_obj = flexitext(text_formatter.left_margin, text_formatter.top_margin, f'<size:22><weight:bold>{track_name}</> replay|laps <weight:bold>firing rate</></>', va="bottom", xycoords="figure fraction")
        footer_text_obj = flexitext((text_formatter.left_margin*0.1), (text_formatter.bottom_margin*0.25), text_formatter._build_footer_string(active_context=active_context), va="top", xycoords="figure fraction")



    """
    margins: FigureMargins = ...
    @property
    def top_margin(self): # -> float:
        ...
    
    @top_margin.setter
    def top_margin(self, value): # -> None:
        ...
    
    @property
    def left_margin(self): # -> float:
        ...
    
    @left_margin.setter
    def left_margin(self, value): # -> None:
        ...
    
    @property
    def right_margin(self): # -> float:
        ...
    
    @right_margin.setter
    def right_margin(self, value): # -> None:
        ...
    
    @property
    def bottom_margin(self): # -> float:
        ...
    
    @bottom_margin.setter
    def bottom_margin(self, value): # -> None:
        ...
    
    def setup_margins(self, fig, **kwargs): # -> None:
        ...
    
    def add_flexitext_context_footer(self, active_context, override_left_margin_multipler: float = ..., override_bottom_margin_multiplier: float = ...):
        """ adds the default footer  """
        ...
    
    def add_flexitext(self, fig, active_context, **kwargs): # -> tuple[Any, Any]:
        ...
    
    @classmethod
    def clear_basic_titles(self, fig): # -> None:
        """ clears the basic title and suptitle in preparation for the flexitext version. """
        ...
    


def plot_position_curves_figure(position_obj, include_velocity=..., include_accel=..., figsize=...): # -> tuple[Figure, list[Any]]:
    """ Renders a figure with a position curve and optionally its higher-order derivatives """
    ...

def draw_epoch_regions(epoch_obj, curr_ax, facecolor=..., edgecolors=..., alpha=..., labels_kwargs=..., defer_render=..., debug_print=..., **kwargs): # -> tuple[BrokenBarHCollection, list[Any] | None]:
    """ plots epoch rectangles with customizable color, edgecolor, and labels on an existing matplotlib axis
    2022-12-14

    Info:
    
    https://matplotlib.org/stable/tutorials/intermediate/autoscale.html
    
    Usage:
        from neuropy.utils.matplotlib_helpers import draw_epoch_regions
        epochs_collection, epoch_labels = draw_epoch_regions(curr_active_pipeline.sess.epochs, ax, defer_render=False, debug_print=False)

    Full Usage Examples:

    ## Example 1:
        active_filter_epochs = curr_active_pipeline.sess.replay
        active_filter_epochs

        if not 'stop' in active_filter_epochs.columns:
            # Make sure it has the 'stop' column which is expected as opposed to the 'end' column
            active_filter_epochs['stop'] = active_filter_epochs['end'].copy()
            
        if not 'label' in active_filter_epochs.columns:
            # Make sure it has the 'stop' column which is expected as opposed to the 'end' column
            active_filter_epochs['label'] = active_filter_epochs['flat_replay_idx'].copy()

        active_filter_epoch_obj = Epoch(active_filter_epochs)
        active_filter_epoch_obj


        fig, ax = plt.subplots()
        ax.plot(post_update_times, flat_surprise_across_all_positions)
        ax.set_ylabel('Relative Entropy across all positions')
        ax.set_xlabel('t (seconds)')
        epochs_collection, epoch_labels = draw_epoch_regions(curr_active_pipeline.sess.epochs, ax, facecolor=('red','cyan'), alpha=0.1, edgecolors=None, labels_kwargs={'y_offset': -0.05, 'size': 14}, defer_render=True, debug_print=False)
        laps_epochs_collection, laps_epoch_labels = draw_epoch_regions(curr_active_pipeline.sess.laps.as_epoch_obj(), ax, facecolor='red', edgecolors='black', labels_kwargs={'y_offset': -16.0, 'size':8}, defer_render=True, debug_print=False)
        replays_epochs_collection, replays_epoch_labels = draw_epoch_regions(active_filter_epoch_obj, ax, facecolor='orange', edgecolors=None, labels_kwargs=None, defer_render=False, debug_print=False)
        fig.show()


    ## Example 2:

        # Show basic relative entropy vs. time plot:
        import matplotlib.pyplot as plt
        fig, ax = plt.subplots()
        ax.plot(post_update_times, flat_relative_entropy_results)
        ax.set_ylabel('Relative Entropy')
        ax.set_xlabel('t (seconds)')
        epochs_collection, epoch_labels = draw_epoch_regions(curr_active_pipeline.sess.epochs, ax, defer_render=False, debug_print=False)
        fig.show()

    """
    ...

def plot_overlapping_epoch_analysis_diagnoser(position_obj, epoch_obj): # -> tuple[Figure, list[Any]]:
    """ builds a MATPLOTLIB figure showing the position and velocity overlayed by the epoch intervals in epoch_obj. Useful for diagnosing overlapping epochs.
    Usage:
        from neuropy.utils.matplotlib_helpers import plot_overlapping_epoch_analysis_diagnoser
        fig, out_axes_list = plot_overlapping_epoch_analysis_diagnoser(sess.position, curr_active_pipeline.sess.laps.as_epoch_obj())
    """
    ...

class MatplotlibFigureExtractors:
    """ 2023-06-26 - Unfinished class that aims to extract matplotlib.figure properties and settings.
    Usage:
        from neuropy.utils.matplotlib_helpers import MatplotlibFigureExtractors
    
    """
    @staticmethod
    def extract_figure_properties(fig): # -> dict[Any, Any]:
        """ UNTESTED, UNFINISHED
        Extracts styles, formatting, and set options from a matplotlib Figure object.
        Returns a dictionary with the following keys:
            - 'title': the Figure title (if any)
            - 'xlabel': the label for the x-axis (if any)
            - 'ylabel': the label for the y-axis (if any)
            - 'xlim': the limits for the x-axis (if any)
            - 'ylim': the limits for the y-axis (if any)
            - 'xscale': the scale for the x-axis (if any)
            - 'yscale': the scale for the y-axis (if any)
            - 'legend': the properties of the legend (if any)
            - 'grid': the properties of the grid (if any)
            
        TO ADD:
            -   fig.get_figwidth()
                fig.get_figheight()
                # fig.set_figheight()

                print(f'fig.get_figwidth(): {fig.get_figwidth()}\nfig.get_figheight(): {fig.get_figheight()}')


            
            Usage:        
                curr_fig = plt.gcf()
                curr_fig = out.figures[0]
                curr_fig_properties = extract_figure_properties(curr_fig)
                curr_fig_properties

        """
        ...
    
    @classmethod
    def extract_fig_suptitle(cls, fig: Figure): # -> tuple[Any, Any | str]:
        """To get the figure's suptitle Text object: https://stackoverflow.com/questions/48917631/matplotlib-how-to-return-figure-suptitle

        Usage:
            from matplotlib.figure import Figure
            from neuropy.utils.matplotlib_helpers import MatplotlibFigureExtractors

            sup, suptitle_string = MatplotlibFigureExtractors.extract_fig_suptitle(fig)
            suptitle_string

        """
        ...
    
    @classmethod
    def extract_titles(cls, fig: Optional[Figure] = ...): # -> dict[Any, Any]:
        """ 
        # Call the function to extract titles
            captured_titles = extract_titles()
            print(captured_titles)
        """
        ...
    


def add_range_selector(fig, ax, initial_selection=..., orientation=..., on_selection_changed=...) -> SpanSelector:
    """ 2023-06-06 - a 1D version of `add_rectangular_selector` which adds a selection band to an existing axis

    from neuropy.utils.matplotlib_helpers import add_range_selector
    curr_pos = deepcopy(curr_active_pipeline.sess.position)
    curr_pos_df = curr_pos.to_dataframe()

    curr_pos_df.plot(x='t', y=['lin_pos'])
    fig, ax = plt.gcf(), plt.gca()
    range_selector, set_extents = add_range_selector(fig, ax, orientation="vertical", initial_selection=None) # (-86.91, 141.02)

    """
    ...

def add_rectangular_selector(fig, ax, initial_selection=..., on_selection_changed=...) -> RectangleSelector:
    """ 2023-05-16 - adds an interactive rectangular selector to an existing matplotlib figure/ax.
    
    Usage:
    
        from neuropy.utils.matplotlib_helpers import add_rectangular_selector

        fig, ax = curr_active_pipeline.computation_results['maze'].computed_data.pf2D.plot_occupancy()
        rect_selector, set_extents = add_rectangular_selector(fig, ax, initial_selection=grid_bin_bounds) # (24.82, 257.88), (125.52, 149.19)

    
    The returned RectangleSelector object can have its selection accessed via:
        rect_selector.extents # (25.508610487986658, 258.5627661142404, 128.10121504465053, 150.48449186696848)
    
    Or updated via:
        rect_selector.extents = (25, 258, 128, 150)

    """
    ...

def interactive_select_grid_bin_bounds_1D(curr_active_pipeline, epoch_name=...): # -> tuple[Any, Any, Any, Any]:
    """ allows the user to interactively select the grid_bin_bounds for the pf1D
    
    Usage:
        from neuropy.utils.matplotlib_helpers import interactive_select_grid_bin_bounds_1D
        fig, ax, range_selector, set_extents = interactive_select_grid_bin_bounds_1D(curr_active_pipeline, epoch_name='maze')
    """
    ...

def interactive_select_grid_bin_bounds_2D(curr_active_pipeline, epoch_name=..., should_block_for_input: bool = ..., should_apply_updates_to_pipeline=...): # -> tuple[Any, Any, Any, Any, Any] | None:
    """ allows the user to interactively select the grid_bin_bounds for the pf2D
    Uses:
        plot_occupancy, add_rectangular_selector


    Usage:
        from neuropy.utils.matplotlib_helpers import interactive_select_grid_bin_bounds_2D
        fig, ax, rect_selector, set_extents, reset_extents = interactive_select_grid_bin_bounds_2D(curr_active_pipeline, epoch_name='maze')
    """
    ...

def perform_update_title_subtitle(fig, ax, title_string: Optional[str], subtitle_string: Optional[str], active_context=..., use_flexitext_titles=...): # -> None:
    """ Only updates the title/subtitle if the value is not None
    
    Usage:
    
    from neuropy.utils.matplotlib_helpers import perform_update_title_subtitle
    perform_update_title_subtitle(fig=fig_long_pf_1D, ax=ax_long_pf_1D, title_string="TEST - 1D Placemaps", subtitle_string="TEST - SUBTITLE")
    
    """
    ...

def matplotlib_configuration_update(is_interactive: bool, backend: Optional[str] = ...): # -> Callable[[], None]:
    """Non-Context manager version for configuring Matplotlib interactivity, backend, and toolbar.
    
    The context-manager version notabily doesn't work for making the figures visible, I think because when it leaves the context handler the variables assigned within go away and thus the references to the Figures are lost.
    
    # Example usage:

        from neuropy.utils.matplotlib_helpers import matplotlib_configuration
        with matplotlib_configuration(is_interactive=False, backend='AGG'):
            # Perform non-interactive Matplotlib operations with 'AGG' backend
            plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
            plt.xlabel('X-axis')
            plt.ylabel('Y-axis')
            plt.title('Non-interactive Mode with AGG Backend')
            plt.savefig('plot.png')  # Save the plot to a file (non-interactive mode)

        with matplotlib_configuration(is_interactive=True, backend='Qt5Agg'):
            # Perform interactive Matplotlib operations with 'Qt5Agg' backend
            plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
            plt.xlabel('X-axis')
            plt.ylabel('Y-axis')
            plt.title('Interactive Mode with Qt5Agg Backend')
            plt.show()  # Display the plot interactively (interactive mode)
    """
    ...

@contextlib.contextmanager
def matplotlib_backend(backend: str): # -> Generator[None, Any, None]:
    """Context manager for switching Matplotlib backend and safely restoring it to its previous value when done.
        # Example usage:
        with matplotlib_backend('AGG'):
            # Perform non-interactive Matplotlib operations
            plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
            plt.xlabel('X-axis')
            plt.ylabel('Y-axis')
            plt.title('Non-interactive Mode')
            plt.savefig('plot.png')  # Save the plot to a file (non-interactive mode)

        with matplotlib_backend('Qt5Agg'):
            # Perform interactive Matplotlib operations
            plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
            plt.xlabel('X-axis')
            plt.ylabel('Y-axis')
            plt.title('Interactive Mode')
            plt.show()  # Display the plot interactively (interactive mode)
    """
    ...

@contextlib.contextmanager
def matplotlib_interactivity(is_interactive: bool): # -> Generator[None, Any, None]:
    """Context manager for switching Matplotlib interactivity mode and safely restoring it to its previous value when done.

    # Example usage:
    with matplotlib_interactivity(is_interactive=False):
        # Perform non-interactive Matplotlib operations
        plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
        plt.xlabel('X-axis')
        plt.ylabel('Y-axis')
        plt.title('Non-interactive Mode')
        plt.show()  # Display the plot (if desired)


    with matplotlib_interactivity(is_interactive=True):
        # Perform interactive Matplotlib operations
        plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
        plt.xlabel('X-axis')
        plt.ylabel('Y-axis')
        plt.title('Interactive Mode')
        plt.show()  # Display the plot immediately (if desired)
    """
    ...

@contextlib.contextmanager
def disable_function_context(obj, fn_name: str): # -> Generator[None, Any, None]:
    """ Disables a function within a context manager

    https://stackoverflow.com/questions/10388411/possible-to-globally-replace-a-function-with-a-context-manager-in-python

    Could be used for plt.show().
    ```python
    
    from neuropy.utils.matplotlib_helpers import disable_function_context
    import matplotlib.pyplot as plt
    with disable_function_context(plt, "show"):
        run_me(x)
    
    """
    ...

@contextlib.contextmanager
def matplotlib_configuration(is_interactive: bool, backend: Optional[str] = ...): # -> Generator[None, Any, None]:
    """Context manager for configuring Matplotlib interactivity, backend, and toolbar.
    # Example usage:

        from neuropy.utils.matplotlib_helpers import matplotlib_configuration
        with matplotlib_configuration(is_interactive=False, backend='AGG'):
            # Perform non-interactive Matplotlib operations with 'AGG' backend
            plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
            plt.xlabel('X-axis')
            plt.ylabel('Y-axis')
            plt.title('Non-interactive Mode with AGG Backend')
            plt.savefig('plot.png')  # Save the plot to a file (non-interactive mode)

        with matplotlib_configuration(is_interactive=True, backend='Qt5Agg'):
            # Perform interactive Matplotlib operations with 'Qt5Agg' backend
            plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
            plt.xlabel('X-axis')
            plt.ylabel('Y-axis')
            plt.title('Interactive Mode with Qt5Agg Backend')
            plt.show()  # Display the plot interactively (interactive mode)
    """
    ...

@contextlib.contextmanager
def matplotlib_file_only(): # -> Generator[None, Any, None]:
    """Context manager for configuring Matplotlib to only render to file, using the 'AGG' backend, no interactivity, and no plt.show()
    # Example usage:
        from neuropy.utils.matplotlib_helpers import matplotlib_file_only
        with matplotlib_file_only():
            # Perform non-interactive Matplotlib operations with 'AGG' backend
            plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
            plt.xlabel('X-axis')
            plt.ylabel('Y-axis')
            plt.title('Non-interactive Mode with AGG Backend')
            plt.savefig('plot.png')  # Save the plot to a file (non-interactive mode)
    """
    ...

def resize_window_to_inches(window, width_inches, height_inches, dpi=...): # -> None:
    """ takes a matplotlib figure size (specified in inches) and the figure dpi to compute the matching pixel size. # If you render a matplotlib figure in a pyqt5 backend window, you can appropriately set the size of this window using this function.

    # Example usage:
        # Assuming you have a QMainWindow instance named 'main_window'
        size=(5,12)
        resize_window_to_inches(mw.window(), *size)

    """
    ...

