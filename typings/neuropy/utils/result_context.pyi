"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, List, Union
from enum import Enum
from attrs import define
from neuropy.utils.mixins.diffable import DiffableObject
from neuropy.utils.mixins.dict_representable import SubsettableDictRepresentable

""" result_context.py

The general goal of these context objects is to be able to generate distinct identifiers for a given result so that it can be serialized to disk and analyzed later.

To do this systematically, we need to be able to identify



For human purposes, it's also incredibly useful to be able to generate minimal-difference versions of these contexts.

For example, if you generated two figures, one with a spatial bin size of 0.5 and another of 1.0 when generating titles for the two plots those two levels of the spatial bin size variable are all that you'd want to keep straight. The rest of the variables aren't changing, and so the minimal-difference required to discriminate between the two cases is only the levels of that variables.
{'bin_size': [0.5, 1.0]}

Let's say you save these out to disk and then a week later see that applying the exact same analyses (with those same two levels) to a different dataset produces an unexpected result at a value of 0.5. You don't remember such a wonky looking graph of 0.5 for the previous dataset, and want to figure out what's going wrong. 

To do this you'll now want to compare the 4 graphs, meaning you'll need to keep track:

Now you have two different datasets: 'earlier' and 'now', each with a minimal-difference of:
    'earlier': {'bin_size': [0.5, 1.0]}
    'now': {'bin_size': [0.5, 1.0]}

To uniquely identify them you'll probably want to visualize them as:

'earlier' (row):    | 'bin_size'=0.5 | 'bin_size'=1.0 | 
'now' (row):        | 'bin_size'=0.5 | 'bin_size'=1.0 |

Ultimately you only have two axes over which things can be compared (rows and columns)
There's one hidden one: 'tabs', 'windows'

Humans need things with distinct, visual groupings. Inclusion Sets, Exceptions (a single outlier rendered in juxtaposition to an inclusion set of the norms)

"""
class CollisionOutcome(Enum):
    """Describes how to update the context when a key that already exists is present."""
    IGNORE_UPDATED = ...
    FAIL_IF_DIFFERENT = ...
    REPLACE_EXISTING = ...
    APPEND_USING_KEY_PREFIX = ...


@define(slots=False, eq=False)
class IdentifyingContext(DiffableObject, SubsettableDictRepresentable):
    """ a general extnsible base context that allows additive member creation
    
        Should not hold any state or progress-related variables. 
    
        # SubsettableDict: provides `to_dict`, `keys`, `keypaths`
        
        
        Usage:
            from neuropy.utils.result_context import IdentifyingContext, CollisionOutcome
            
        The user should be able to query a list of IdentifyingContext items and find all that match a certain criteria.
        For an example dictionary containing dictionaries with values for each of the IdentifyingContexts:
            _specific_session_override_dict = { 
                IdentifyingContext(format_name='kdiba',animal='gor01',exper_name='one',session_name='2006-6-08_14-26-15'):{'grid_bin_bounds':((29.16, 261.70), (130.23, 150.99))},
                IdentifyingContext(format_name='kdiba',animal='gor01',exper_name='two',session_name='2006-6-07_16-40-19'):{'grid_bin_bounds':((22.397021260868584, 245.6584673739576), (133.66465594522782, 155.97244934208123))},
                IdentifyingContext(format_name='kdiba',animal='gor01',exper_name='two',session_name='2006-6-08_21-16-25'):dict(grid_bin_bounds=(((17.01858788173554, 250.2171441367766), (135.66814125966783, 154.75073313142283)))),
                IdentifyingContext(format_name='kdiba',animal='gor01',exper_name='two',session_name='2006-6-09_22-24-40'):{'grid_bin_bounds':(((29.088604852961407, 251.70402561515647), (138.496638485457, 154.30675703402517)))},
                IdentifyingContext(format_name='kdiba',animal='vvp01',exper_name='one',session_name='2006-4-09_17-29-30'):{'grid_bin_bounds':(((29.16, 261.7), (133.87292045454544, 150.19888636363635)))},
                IdentifyingContext(format_name='kdiba',animal='vvp01',exper_name='one',session_name='2006-4-10_12-25-50'):{'grid_bin_bounds':((25.5637332724328, 257.964172947664), (89.1844223602494, 131.92462510535915))},
                IdentifyingContext(format_name='kdiba',animal='vvp01',exper_name='two',session_name='2006-4-09_16-40-54'):{'grid_bin_bounds':(((19.639345624112345, 248.63934562411234), (134.21607306829767, 154.57926689187622)))},
                IdentifyingContext(format_name='kdiba',animal='gor01',exper_name='one',session_name='2006-6-09_1-22-43'):dict(grid_bin_bounds=(((36.58620390950715, 248.91627658974846), (132.81136363636367, 149.2840909090909)))),
                IdentifyingContext(format_name='kdiba',animal='gor01',exper_name='one',session_name='2006-6-09_3-23-37'):{'grid_bin_bounds':(((29.64642522460817, 257.8732552112081), (106.68603845428224, 146.71219371189815)))},
            }
            # Example Query 1: To find any relevent entries for the 'exper_name'=='one':
                    IdentifyingContext(format_name='kdiba',animal='gor01',exper_name='one',session_name='2006-6-08_14-26-15'):{'grid_bin_bounds':((29.16, 261.70), (130.23, 150.99))},
                    IdentifyingContext(format_name='kdiba',animal='vvp01',exper_name='one',session_name='2006-4-09_17-29-30'):{'grid_bin_bounds':(((29.16, 261.7), (133.87292045454544, 150.19888636363635)))},
                    IdentifyingContext(format_name='kdiba',animal='vvp01',exper_name='one',session_name='2006-4-10_12-25-50'):{'grid_bin_bounds':((25.5637332724328, 257.964172947664), (89.1844223602494, 131.92462510535915))},
                    IdentifyingContext(format_name='kdiba',animal='gor01',exper_name='one',session_name='2006-6-09_1-22-43'):dict(grid_bin_bounds=(((36.58620390950715, 248.91627658974846), (132.81136363636367, 149.2840909090909)))),
                    IdentifyingContext(format_name='kdiba',animal='gor01',exper_name='one',session_name='2006-6-09_3-23-37'):{'grid_bin_bounds':(((29.64642522460817, 257.8732552112081), (106.68603845428224, 146.71219371189815)))},

                    # Test 1: To find any relevant entries for the 'exper_name' == 'one'
                    relevant_entries = [ic for ic, _ in identifying_context_list if ic.query({'exper_name': 'one'})]

            
            # Example Query 2: To find any relevent entries for the 'animal'=='vvp01':
                IdentifyingContext(format_name='kdiba',animal='vvp01',exper_name='one',session_name='2006-4-09_17-29-30'):{'grid_bin_bounds':(((29.16, 261.7), (133.87292045454544, 150.19888636363635)))},
                IdentifyingContext(format_name='kdiba',animal='vvp01',exper_name='one',session_name='2006-4-10_12-25-50'):{'grid_bin_bounds':((25.5637332724328, 257.964172947664), (89.1844223602494, 131.92462510535915))},
                IdentifyingContext(format_name='kdiba',animal='vvp01',exper_name='two',session_name='2006-4-09_16-40-54'):{'grid_bin_bounds':(((19.639345624112345, 248.63934562411234), (134.21607306829767, 154.57926689187622)))},
        
                # Test 2: To find any relevant entries for the 'animal' == 'vvp01'
                relevant_entries = [ctxt for ctxt, _ in self.identifying_context_list if ctxt.query({'animal': 'vvp01'})]
        
                
        Query Usage:
            # Test 2: To find any relevant entries for the 'animal' == 'vvp01'
            relevant_entries = [ctxt for ctxt, _ in self.identifying_context_list if ctxt.query({'animal': 'vvp01'})]

            # Test 2: To find any relevant entries for the 'animal' == 'vvp01'
            relevant_entries = {ctxt:v for ctxt,v in identifying_context_dict.items() if ctxt.query({'animal': 'vvp01'})]    
                
    """
    def __init__(self, **kwargs) -> None:
        ...
    
    @classmethod
    def matching(cls, context_iterable: Union[Dict[IdentifyingContext, Any], List[IdentifyingContext]], criteria: Union[Dict[str, Any], IdentifyingContext]) -> Union[Dict[IdentifyingContext, Any], List[IdentifyingContext]]:
        """ 
        Queries the iterable (either list of dict with IdentifyingContext as keys) and returns the values matching the criteria
        criteria={'animal': 'vvp01'}
        
        Usage:
        
        annotations_man = UserAnnotationsManager()
        identifying_context_dict = annotations_man.get_hardcoded_specific_session_override_dict()

        relevant_entries = IdentifyingContext.matching(identifying_context_dict, criteria={'animal': 'vvp01'})
        
        """
        ...
    
    def query(self, criteria: Union[Dict[str, Any], IdentifyingContext]) -> bool:
        """
        Checks if the IdentifyingContext instance matches the given criteria.

        Parameters
        ----------
        criteria : Dict[str, Any]
            A dictionary where keys are attribute names and values are attribute values that an
            IdentifyingContext instance should have to match the criteria.

        Returns
        -------
        bool
            True if the IdentifyingContext instance matches the criteria, False otherwise.
        """
        ...
    
    @classmethod
    def find_unique_values(cls, context_iterable: List[IdentifyingContext]) -> dict:
        """
        Takes a list of IdentifyingContext objects and finds all of the unique values
        for each of their shared keys.

        Parameters
        ----------
        ic_list : list
            A list of IdentifyingContext objects.

        Returns
        -------
        dict
            A dictionary where keys are attribute names shared by all IdentifyingContext objects in the list,
            and values are sets of unique attribute values.
            
        Example:
        
        {'format_name': {'kdiba'},
        'animal': {'gor01', 'pin01', 'vvp01'},
        'exper_name': {'one', 'two'},
        'session_name': {'11-02_17-46-44','2006-4-09_16-40-54', '2006-4-09_17-29-30', '2006-4-10_12-25-50', '2006-6-07_16-40-19', '2006-6-08_14-26-15', '2006-6-08_21-16-25', '2006-6-09_1-22-43', '2006-6-09_22-24-40', '2006-6-12_15-55-31', '2006-6-12_16-53-46', 'fet11-01_12-58-54'}
        }
        """
        ...
    
    def add_context(self, collision_prefix: str, strategy: CollisionOutcome = ..., **additional_context_items): # -> Self:
        """ adds the additional_context_items to self 
        collision_prefix: only used when an attr name in additional_context_items already exists for this context and the values of that attr are different
        
        """
        ...
    
    def adding_context(self, collision_prefix: str, strategy: CollisionOutcome = ..., **additional_context_items) -> IdentifyingContext:
        """ returns a new IdentifyingContext that results from adding additional_context_items to a copy of self 
        collision_prefix: only used when an attr name in additional_context_items already exists for this context and the values of that attr are different
        
        """
        ...
    
    @classmethod
    def resolve_key(cls, duplicate_ctxt: IdentifyingContext, name: str, value, collision_prefix: str, strategy: CollisionOutcome = ...): # -> str | None:
        """ensures no collision between attributes occur, and if they do resolve them according to strategy. e.g. rename them with an identifying prefix
        Returns the resolved key (str) or None.
        """
        ...
    
    def adding_context_if_missing(self, **additional_context_items) -> IdentifyingContext:
        ...
    
    def overwriting_context(self, **additional_context_items) -> IdentifyingContext:
        ...
    
    def merging_context(self, collision_prefix: str, additional_context: IdentifyingContext) -> IdentifyingContext:
        """ returns a new IdentifyingContext that results from adding the items in additional_context to a copy of self 
            collision_prefix: only used when an attr name in additional_context_items already exists for this context and the values of that attr are different    
        """
        ...
    
    def __or__(self, other): # -> IdentifyingContext:
        """ Used with vertical bar operator: |
        Usage:
            (_test_complete_spike_analysis_config | _test_partial_spike_analysis_config)    
        """
        ...
    
    def get_description(self, subset_includelist=..., subset_excludelist=..., separator: str = ..., include_property_names: bool = ..., replace_separator_in_property_names: str = ..., key_value_separator=..., prefix_items=..., suffix_items=...) -> str:
        """ returns a simple text descriptor of the context
        
        include_property_names: str - whether to include the keys/names of the properties in the output string or just the values
        replace_separator_in_property_names: str = replaces occurances of the separator with the str specified for the included property names. has no effect if include_property_names=False
        key_value_separator: Optional[str] = if None, uses the same separator between key{}value as used between items.
        
        Outputs:
            a str like 'sess_kdiba_2006-6-07_11-26-53'
        """
        ...
    
    def get_initialization_code_string(self, subset_includelist=..., subset_excludelist=...) -> str:
        """ returns the string that contains valid code to initialize a matching object. """
        ...
    
    def __str__(self) -> str:
        """ 'kdiba_2006-6-08_14-26-15_maze1_PYR' """
        ...
    
    def __repr__(self) -> str:
        """ 
            "IdentifyingContext({'format_name': 'kdiba', 'session_name': '2006-6-08_14-26-15', 'filter_name': 'maze1_PYR'})" 
            "IdentifyingContext<('kdiba', '2006-6-08_14-26-15', 'maze1_PYR')>"
        """
        ...
    
    def __hash__(self) -> int:
        """ custom hash function that allows use in dictionary just based off of the values and not the object instance. """
        ...
    
    def __eq__(self, other) -> bool:
        """Overrides the default implementation"""
        ...
    
    @classmethod
    def init_from_dict(cls, a_dict): # -> Self:
        ...
    
    def get_subset(self, subset_includelist=..., subset_excludelist=...) -> IdentifyingContext:
        """ returns a proper subset of self given the incldued/exclude lists. """
        ...
    
    def subtracting(self, rhs) -> IdentifyingContext:
        ...
    
    @classmethod
    def subtract(cls, lhs, rhs): # -> Self:
        """ Returns the lhs less the keys that are in the rhs.
        Example:
            non_primary_desired_files = FileList.subtract(found_any_pickle_files, (found_default_session_pickle_files + found_global_computation_results_files))        
        """
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    @classmethod
    def try_extract_date_from_session_name(cls, session_name: str, assumed_year_if_missing: str = ..., debug_print: bool = ...): # -> Timestamp | NaTType | None:
        """ 2023-08-24 - Attempts to determine at least the relative recording date for a given session from the session's name alone.
        From the 'session_name' column in the provided data, we can observe two different formats used to specify the date:

        Format 1: Dates with the pattern YYYY-M-D_H-M-S (e.g., "2006-6-07_11-26-53").
        Format 2: Dates with the pattern MM-DD_H-M-S (e.g., "11-02_17-46-44").
        
        """
        ...
    


def print_args(func): # -> Callable[..., Any]:
    """ A decorator that extracts the arguments from its decorated function and prints them 

    Example:

        @print_args
        def add(x, y):
            return x + y

        >> add(2, 5)
            Arguments: (2, 5)
            Keyword arguments: {}

    """
    ...

def overwriting_display_context(**additional_context_kwargs): # -> Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    """Adds to the context of the function or class

    Usage:
        from neuropy.utils.result_context import overwriting_display_context
        @overwriting_display_context('tag1', 'tag2')
        def my_function():
            ...

        Access via:
            my_function.active_context

    """
    ...

def providing_context(**additional_context_kwargs): # -> Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    """Specifies additional (narrowing) context for use in the function or class
    
    Usage:
        from neuropy.utils.result_context import overwriting_display_context
        @overwriting_display_context('tag1', 'tag2')
        def my_function():
            ...

        Access via:
            my_function.active_context

    """
    ...

