"""
This type stub file was generated by pyright.
"""

from collections.abc import MutableMapping
from neuropy.utils.mixins.diffable import DiffableObject

def get_dict_subset(a_dict, included_keys=..., require_all_keys=...): # -> dict[Any, Any]:
    """Gets a subset of a dictionary from a list of keys (included_keys)

    Args:
        a_dict ([type]): [description]
        included_keys ([type], optional): [description]. Defaults to None.
        require_all_keys: Bool, if True, requires all keys in included_keys to be in the dictionary (a_dict)

    Returns:
        [type]: [description]
    """
    ...

def override_dict(lhs_dict, rhs_dict):
    """returns lhs_dict overriden with the values specified in rhs_dict (if they exist), otherwise returning the extant values.
    """
    ...

def overriding_dict_with(lhs_dict, **kwargs):
    """returns lhs_dict overriden with the kwargs provided (if they exist), otherwise returning the extant values.
        Calls self.__ior__(other) under the hood.
    """
    ...

class DynamicContainer(DiffableObject, MutableMapping):
    """ A class that permits flexible prototyping of parameters and data needed for computations, while still allowing development-time guidance on available members.
        From https://treyhunner.com/2019/04/why-you-shouldnt-inherit-from-list-and-dict-in-python/#When_making_a_custom_list_or_dictionary,_remember_you_have_options
        The UserDict class implements the interface that dictionaries are supposed to have, but it wraps around an actual dict object under-the-hood.
        The UserList and UserDict classes are for when you want something that acts almost identically to a list or a dictionary but you want to customize just a little bit of functionality.
        The abstract base classes in collections.abc are useful when you want something thatâ€™s a sequence or a mapping but is different enough from a list or a dictionary that you really should be making your own custom class.
    """
    debug_enabled = ...
    outcome_on_item_not_found = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __dir__(self): # -> KeysView[Any]:
        ...
    
    def __or__(self, other): # -> DynamicContainer:
        """ Used with vertical bar operator: |
        
        Usage:
            (_test_complete_spike_analysis_config | _test_partial_spike_analysis_config)    
        """
        ...
    
    def __ior__(self, other): # -> DynamicContainer:
        """ Used with vertical bar equals operator: |=
        
        Unlike __or__(self, other), does not allow keys present ONLY in other to be added to self.
            Identically like __or__(self, other) though, if a key is present in both self and other the value in OTHER will be used. 
        
        Usage:
            # Explicit __ior__ usage:
            out = DynamicContainer(**{'s': 2, 'gamma': 0.2}).__ior__(kwargs)

            # Multi-line "override" update:
            out = DynamicContainer(**{'s': 2, 'gamma': 0.2})
            out|=kwargs
            
            # WARNING: this is wrong! Must first have a DynamicContainer to call __ior__ on, not a plain dict inside the DynamicContainer initializer
            out = DynamicContainer(**({'s': 2, 'gamma': 0.2}.__ior__(kwargs))) # |=

        Testing:
        def _test_xor(**kwargs):
            # want it only to pass 's' and 'gamma' keys to create the container despite more keys being present in kwargs
            # out = DynamicContainer(**{'s': 2, 'gamma': 0.2}).__ior__(kwargs) # |=
            out = DynamicContainer(**{'s': 2, 'gamma': 0.2}).override(kwargs)
            # out = DynamicContainer(**{'s': 2, 'gamma': 0.2})
            # out|=kwargs
            print(f'{out}')
            return out
            # dict_or = self.to_dict().__or__(other_dict)
            
        _test_xor(s=3) # DynamicContainer({'s': 3, 'gamma': 0.2})
        _test_xor(s=3, m='vet') # DynamicContainer({'s': 3, 'gamma': 0.2})
        _test_xor(s=3, m='vet', gamma=0.9) # DynamicContainer({'s': 3, 'gamma': 0.9})

        """
        ...
    
    def overriding_with(self, **kwargs): # -> DynamicContainer:
        """returns self overriden with the kwargs provided (if they exist), otherwise returning the extant values.
            Calls self.__ior__(other) under the hood.
        """
        ...
    
    def override(self, other): # -> DynamicContainer:
        """returns self overriden with the values specified in other (if they exist), otherwise returning the extant values.
            Calls self.__ior__(other) under the hood.
        """
        ...
    
    def __getattr__(self, item):
        ...
    
    def __setattr__(self, attr, value): # -> Callable[[], None] | None:
        ...
    
    @property
    def all_attributes(self): # -> list[Any]:
        """Any attributes on the object. """
        ...
    
    @property
    def original_attributes(self): # -> list[str]:
        """The attributes that were provided initially at init. """
        ...
    
    @property
    def dynamically_added_attributes(self): # -> list[Any]:
        """The attributes that were added dynamically post-init."""
        ...
    
    def __hash__(self) -> int:
        """ custom hash function that allows use in dictionary just based off of the values and not the object instance. """
        ...
    
    def diff(self, other_object): # -> set[Any]:
        ...
    
    def to_dict(self): # -> dict[Any, Any]:
        ...
    
    @classmethod
    def init_from_dict(cls, a_dict): # -> Self:
        ...
    
    @classmethod
    def init_from_object(cls, an_object): # -> Self:
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


