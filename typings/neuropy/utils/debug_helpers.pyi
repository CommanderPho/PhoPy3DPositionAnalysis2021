"""
This type stub file was generated by pyright.
"""

from typing import Callable

def inspect_callable_arguments(a_callable: Callable, debug_print=...): # -> tuple[FullArgSpec, list[str], list[str], dict[Any, Any]]:
    """ Not yet validated/implemented
    Progress:
        import inspect
        from neuropy.plotting.ratemaps import plot_ratemap_1D, plot_ratemap_2D

        fn_spec = inspect.getfullargspec(plot_ratemap_2D)
        fn_sig = inspect.signature(plot_ratemap_2D)
        ?fn_sig

            # fn_sig
        dict(fn_sig.parameters)
        # fn_sig.parameters.values()

        fn_sig.parameters['plot_mode']
        # fn_sig.parameters
        fn_spec.args # all kwarg arguments: ['x', 'y', 'num_bins', 'debug_print']

        fn_spec.defaults[-2].__class__.__name__ # a tuple of default values corresponding to each argument in args; ((64, 64), False)
    """
    ...

def safely_accepts_kwargs(fn): # -> Callable[..., Any]:
    """ builds a wrapped version of fn that only takes the kwargs that it can use, and shrugs the rest off 
    Can be used as a decorator to make any function gracefully accept unhandled kwargs

    Can be used to conceptually "splat" a configuration dictionary of properties against a function that only uses a subset of them, such as might need to be done for plotting, etc)
    
    Usage:
        @safely_accepts_kwargs
        def _test_fn_with_limited_parameters(item1=None, item2='', item3=5.0):
            print(f'item1={item1}, item2={item2}, item3={item3}')
            
            
    TODO: Tests:
        from neuropy.utils.debug_helpers import safely_accepts_kwargs

        # def _test_fn_with_limited_parameters(newitem, item1=None, item2='', item3=5.0):
        #     print(f'item1={item1}, item2={item2}, item3={item3}')

        @safely_accepts_kwargs
        def _test_fn_with_limited_parameters(item1=None, item2='', item3=5.0):
            print(f'item1={item1}, item2={item2}, item3={item3}')

        @safely_accepts_kwargs
        def _test_fn2_with_limited_parameters(itemA=None, itemB='', itemC=5.0):
            print(f'itemA={itemA}, itemB={itemB}, itemC={itemC}')
            
        def _test_outer_fn(**kwargs):
            _test_fn_with_limited_parameters(**kwargs)
            _test_fn2_with_limited_parameters(**kwargs)
            # _test_fn_with_limited_parameters(**overriding_dict_with(lhs_dict=fn_spec_default_arg_dict, **kwargs))
            # _test_fn2_with_limited_parameters(**overriding_dict_with(lhs_dict=fn_spec_default_arg_dict, **kwargs))
            
            # Build safe versions of the functions
            # _safe_test_fn_with_limited_parameters = _build_safe_kwargs(_test_fn_with_limited_parameters)
            # _safe_test_fn2_with_limited_parameters = _build_safe_kwargs(_test_fn2_with_limited_parameters)
            # Call the safe versions:
            # _safe_test_fn_with_limited_parameters(**kwargs)
            # _safe_test_fn2_with_limited_parameters(**kwargs)
            
            
        # _test_outer_fn()
        _test_outer_fn(itemB=15) # TypeError: _test_fn_with_limited_parameters() got an unexpected keyword argument 'itemB'

    """
    ...

def debug_print_ratemap(ratemap): # -> None:
    ...

def debug_print_placefield(active_epoch_placefield, short=...): # -> DataFrame[Any]:
    ...

def debug_print_spike_counts(session): # -> None:
    ...

def debug_plot_2d_binning(xbin, ybin, xbin_center, ybin_center): # -> Figure:
    """ Displays the locations of the x & y bins and their center equivalents on a 2D plot
    Usage: 
        fig = debug_plot_2d_binning(active_epoch_placefields2D.ratemap.xbin, active_epoch_placefields2D.ratemap.ybin, active_epoch_placefields2D.ratemap.xbin_centers, active_epoch_placefields2D.ratemap.ybin_centers)
    """
    ...

def debug_print_subsession_neuron_differences(prev_session_Neurons, subsession_Neurons): # -> None:
    ...

def print_aligned_columns(column_labels, column_values, pad_fill_str: str = ..., enable_print: bool = ..., enable_string_return: bool = ..., enable_checking_all_values_width: bool = ...): # -> tuple[LiteralString, Any | list[Any]] | None:
    """ Prints a text representation of a table of values. All columns must have the same number of rows.

    enable_checking_all_values_width: if True, will compute the explicit width of the string representation of each element in the table and use the maximum of those widths as the width for that column. If False, will use the width of the column label as the width for that column.

    Usage:
        pad_fill_str = ' ' # the string to pad with
        list_of_names = ['frate_thresh', 'num_good_neurons', 'num_total_spikes']
        list_of_values = [frate_thresh_options, num_good_placefield_neurons_list, num_total_spikes_list]
        print_aligned_columns(list_of_names, list_of_values, pad_fill_str = ' ')

        Example Output:

        frate_thresh  num_good_neurons  num_total_spikes  
        0.0           70                58871             
        0.1           70                58871             
        1.0           65                57937             
        5.0           35                38800             
        10.0          14                20266             
        100.0         0                 0.0               


    """
    ...

def compare_placefields_info(output_pfs): # -> tuple[list[Any], list[Any], list[Any]]:
    """Compares a list of placefields

    Args:
        output_pfs (_type_): _description_

    Returns:
        _type_: _description_

    Usage:

        num_good_placefield_neurons_list, num_total_spikes_list, num_spikes_per_spiketrain_list = compare_placefields_info(output_pfs)

    """
    ...

def parameter_sweeps(**kwargs): # -> tuple[list[Any], dict[str, int]]:
    """ Returns every unique combination of the passed in parameters. Superior to cartesian_product as it preserves the labels (returning a flat list of dicts) and accepts more than 2 inputs.
    
    Usage:
        from neuropy.utils.debug_helpers import parameter_sweeps
        all_param_sweep_options, param_sweep_option_n_values = parameter_sweeps(smooth=[(None, None), (0.5, 0.5), (1.0, 1.0), (2.0, 2.0), (5.0, 5.0)], grid_bin=[(1,1),(5,5),(10,10)])
        >> all_param_sweep_options:  [{'smooth': (None, None), 'grid_bin': (1, 1)}, {'smooth': (None, None), 'grid_bin': (5, 5)}, {'smooth': (None, None), 'grid_bin': (10, 10)},
        {'smooth': (0.5, 0.5), 'grid_bin': (1, 1)},  {'smooth': (0.5, 0.5), 'grid_bin': (5, 5)},  {'smooth': (0.5, 0.5), 'grid_bin': (10, 10)},
        {'smooth': (1.0, 1.0), 'grid_bin': (1, 1)}, ...]
        >> param_sweep_option_n_values: {'smooth': 5, 'grid_bin': 3}

        # !! SEE EXAMPLE BELOW `_compute_parameter_sweep` for usage of the returned values
        
    NOTE:
        Replaces:
            all_param_sweep_options = cartesian_product(grid_bin_options, smooth_options)
            param_sweep_option_n_values = dict(grid_bin=len(grid_bin_options), smooth=len(smooth_options)) 

    """
    ...

