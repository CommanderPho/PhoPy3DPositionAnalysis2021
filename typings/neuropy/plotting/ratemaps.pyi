"""
This type stub file was generated by pyright.
"""

import enum
from typing import TYPE_CHECKING
from neuropy.core.neuron_identities import PlotStringBrevityModeEnum
from neuropy.core.ratemap import Ratemap
from neuropy.utils.misc import RowColTuple
from neuropy.utils.matplotlib_helpers import enumTuningMap2DPlotMode, enumTuningMap2DPlotVariables
from neuropy.utils.debug_helpers import safely_accepts_kwargs

module_logger = ...
if TYPE_CHECKING:
    ...
class BackgroundRenderingOptions(enum.Enum):
    PATTERN_CHECKERBOARD = ...
    SOLID_COLOR = ...
    EMPTY = ...


@safely_accepts_kwargs
def plot_ratemap_2D(ratemap: Ratemap, computation_config=..., included_unit_indicies=..., included_unit_neuron_IDs=..., subplots: RowColTuple = ..., fig_column_width: float = ..., fig_row_height: float = ..., resolution_multiplier: float = ..., max_screen_figure_size=..., fignum=..., fig=..., enable_spike_overlay=..., spike_overlay_spikes=..., extended_overlay_points_datasource_dicts=..., drop_below_threshold: float = ..., brev_mode: PlotStringBrevityModeEnum = ..., plot_variable: enumTuningMap2DPlotVariables = ..., plot_mode: enumTuningMap2DPlotMode = ..., bg_rendering_mode=..., use_special_overlayed_title=..., missing_aclu_string_formatter=..., debug_print=...): # -> tuple[list[Any], list[Any], list[Any]]:
    """Plots heatmaps of placefields with peak firing rate
    
    Internally calls plot_single_tuning_map_2D(...) for each individual ratemap (regardless of the plot_mode)
    
    Parameters
    ----------
    speed_thresh : bool, optional
        [description], by default False
    subplots : tuple, optional
        number of cells within each figure window. If cells exceed the number of subplots, then cells are plotted in successive figure windows of same size, by default (10, 8)
    fignum : int, optional
        figure number to start from, by default None
    fig_subplotsize: tuple, optional
        fig_subplotsize: the size of a single subplot. used to compute the figure size
        
        
    spike_overlay_spikes: a 
    
    extended_overlay_points_datasource_dicts: a general dict of additional overlay point datasources to potentially add to the images. Each is passed to _add_points_to_plot(...)
        TODO: NOTE: currently the subplot the points are plotted on is determined by getting: `a_datasource['points_data'][neuron_IDX]`, meaning the assumption is that each datasource has one xy point to draw for every neuron. Obviously it would be better if multiple points could be provided for each neuron, so really the datasource should be re-speced to have a function that takes the neuron_id and returns the desired values (kinda like a datasource of datasources, or maybe a dataframe that it filters to get the points, that might be more 'flat' of a design. 
        
        Example:
            # overlay_points data
            peaks_overlay_points_data_dict = dict(is_enabled=True, points_data=peak_xy_points_pos_list, plot_opts={'markersize': 28, 'marker': '*', 'markeredgecolor': 'grey', 'linestyle': 'none', 'markerfacecolor': 'white', 'alpha': 0.9, 'label': 'peaks_overlay_points'},
                                                                                        scatter_opts={'s': 28, 'c': 'white', 'alpha': 0.9, 'marker': '*', 'label': 'peaks_overlay_sc'}, plots={})

            extended_overlay_points_datasource_dicts = {'peaks_overlay_points': peaks_overlay_points_data_dict}

    
    
    # TODO: maybe add a fig property: an explicit figure to use instead of fignum
    
    
    TODO: Cleaning up with  grid_layout_mode == 'imagegrid'
    plot_mode == 


    Returns:
            active_graphics_obj_dict[curr_neuron_ID] = {'axs': [curr_ax], 'image': curr_im, 'title_obj': curr_title_anchored_text}
    """
    ...

@safely_accepts_kwargs
def plot_ratemap_1D(ratemap: Ratemap, normalize_xbin=..., fignum=..., fig=..., ax=..., pad=..., normalize_tuning_curve=..., sortby=..., cmap=..., included_unit_indicies=..., included_unit_neuron_IDs=..., brev_mode: PlotStringBrevityModeEnum = ..., plot_variable: enumTuningMap2DPlotVariables = ..., curve_hatch_style=..., missing_aclu_string_formatter=..., single_cell_pfmap_processing_fn=..., active_context=..., use_flexitext_titles=..., use_flexitext_ticks=..., ytick_location_shift: float = ..., plot_zero_baselines: bool = ..., skip_figure_titles: bool = ..., flat_stack_mode: bool = ..., debug_print=...): # -> tuple[Axes | Any, NDArray[Any] | NDArray[intp] | ndarray[Any, Any], ndarray[Any, Any]]:
    """Plot 1D place fields stacked

    Parameters
    ----------
    ax : [type], optional
        [description], by default None
    speed_thresh : bool, optional
        [description], by default False
    pad : int, optional
        [description], by default 2
    normalize : bool, optional
        [description], by default False
    sortby : bool, optional
        [description], by default True
    cmap : str, optional
        [description], by default "tab20b"
    curve_hatch_style : dict, optional
        if curve_hatch_style is not None, hatch marks are drawn inside the plotted curves, by default None
    missing_aclu_string_formatter: a lambda function that takes the current aclu string and returns a modified string that reflects that this aclu value is missing from the current result (e.g. missing_aclu_string_formatter('3') -> '3 <shared>')
    single_cell_pfmap_processing_fn: Callable (lambda i, aclu, pfmap) - takes the index, aclu, and pfmap and returns a potentially modified pfmap 
    ytick_location_shift: float, default 0.5
        The amount of shift in y-position for the ticks that represents each aclu
    plot_zero_baselines: bool, default True
        If True, plots the baseline for each plot. Useful for plotting a comparison where one is reflected over the y-axis
    skip_figure_titles: bool, default False
        if True, no figure titles are rendered of any type. This is useful if you want to set the titles later (for example for a shared long/short plot)
    flat_stack_mode: bool, default False
        if True, instead of cells being vertically offset from each other as a vertical stack of virtual axes they are rendered as a overlayed axis.
        
    Returns
    -------
    [type]
        [description]


    Notes:
    Unlike the plot_ratemap_2D(...), this version seems to plot all the cells on a single axis: using `ax.set_yticklabels(list(sorted_neuron_id_labels))` to label each cell's tuning curve and offsets to plot them.

    ALTERNATIVES: when there are no neurons, we might want to do the procedure outlined in `# invalid neuron ID, generate blank entry` instead of returning a blank figure.

    """
    ...

@safely_accepts_kwargs
def plot_raw(ratemap: Ratemap, t, x, run_dir, ax=..., subplots=...): # -> None:
    """Plot spike location on animal's path

    Parameters
    ----------
    speed_thresh : bool, optional
        [description], by default False
    ax : [type], optional
        [description], by default None
    subplots : tuple, optional
        [description], by default (8, 9)
    """
    ...

